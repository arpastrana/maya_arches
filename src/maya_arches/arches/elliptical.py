from math import sqrt
from math import pi
from math import cos
from math import sin

from compas.geometry import Point

from maya_arches.arches import Arch


# ------------------------------------------------------------------------------
# Elliptical arch
# ------------------------------------------------------------------------------

class EllipticalArch(Arch):
    """
    A half-elliptical arch.
    """
    def __init__(self, height: float, width: float, thickness: float, **kwargs):
        super().__init__()
        self._height = height
        self._width = width
        self._thickness = thickness

        self._check_thickness()

    def _check_thickness(self):
        """
        Check the thickness of the arch.
        """
        if self.thickness > self.height:
            raise ValueError("Arch thickness cannot be greater than the height!")
        if self.thickness > self.width:
            raise ValueError("Arch thickness cannot be greater than the width!")

    @property
    def height(self) -> float:
        """
        The height of the arch.
        """
        return self._height

    @property
    def width(self) -> float:
        """
        The width of the arch.
        """
        return self._width

    @property    
    def thickness(self) -> float:
        """
        The thickness of the arch. 

        The thickness is exact at the base and the top of the arch due to the
        simple offset applied to the points of the extrados and intrados.
        """
        return self._thickness

    @property
    def support_width(self) -> float:
        """
        The width of the arch's support.
        """
        return self.thickness

    @property
    def span(self) -> float:
        """
        The span of the arch.
        """
        return 2 * (self.width - self.thickness)

    def points(self, num_points: int = 100) -> list[Point]:
        """
        The points of the arch.

        Notes
        ------
        The points are generated by concatenating two elliptical arcs.
        Therefore, the normal distance between the extrados and intrados is
        not guaranteed to be exactly twice the thickness of the arch, except 
        at the base and the top of the arch.
        """
        radius_1 = self.height
        radius_2 = self.width
        points_extrados = points_elliptical_arc(radius_1, radius_2, num_points)

        radius_3 = radius_1 - self.thickness
        radius_4 = radius_2 - 2 * self.thickness
        points_intrados = points_elliptical_arc(radius_3, radius_4, num_points)

        def shift_points_x(points, offset):
            return [[point[0] + offset, point[1], 0.0] for point in points]

        shift = radius_2 * 0.5
        points_extrados = shift_points_x(points_extrados, shift)
        points_intrados = shift_points_x(points_intrados, shift)

        return points_extrados + points_intrados[::-1]

    def __str__(self, params_other: dict = None) -> str:
        """
        Return a string description of this arch.
        """
        params = {'thickness': self.thickness}

        return super().__str__(params)


# ------------------------------------------------------------------------------
# Elliptical arch
# ------------------------------------------------------------------------------

class EllipticalTaperedArch(EllipticalArch):
    """
    A half-elliptical arch with a tapered intrados.
    """
    def __init__(self, height: float, width: float, thickness_top: float, thickness_bottom: float, **kwargs):
        self.thickness_top = thickness_top
        self.thickness_bottom = thickness_bottom
        super().__init__(height, width, thickness_top)        

        self._check_thickness()

    def _check_thickness(self):
        """
        Check the thickness of the arch.
        """
        if self.thickness_top > self.height:
            raise ValueError("The top thickness of the arch cannot be greater than the height.")
        if self.thickness_bottom > self.width:
            raise ValueError("The bottom thickness of the arch cannot be greater than the width.")

    @property    
    def thickness(self) -> float:
        """
        The top thickness of the arch. 

        The thickness is exact at the base and the top of the arch due to the
        simple offset applied to the points of the extrados and intrados.
        """
        return self.thickness_top

    @property
    def support_width(self) -> float:
        """
        The width of the arch's support.
        """
        return self.thickness_bottom

    @property
    def span(self) -> float:
        """
        The span of the arch.
        """
        return 2 * (self.width - self.support_width)

    def points(self, num_points: int = 100) -> list[Point]:
        """
        The points of the arch.

        Notes
        ------
        The points are generated by concatenating two elliptical arcs.
        Therefore, the normal distance between the extrados and intrados is
        not guaranteed to be exactly twice the thickness of the arch, except 
        at the base and the top of the arch.
        """
        radius_1 = self.height
        radius_2 = self.width
        points_extrados = points_elliptical_arc(radius_1, radius_2, num_points)

        radius_3 = radius_1 - self.thickness_top
        radius_4 = radius_2 - 2 * self.thickness_bottom
        points_intrados = points_elliptical_arc(radius_3, radius_4, num_points)

        def shift_points_x(points, offset):
            return [[point[0] + offset, point[1], 0.0] for point in points]

        shift = radius_2 * 0.5
        points_extrados = shift_points_x(points_extrados, shift)
        points_intrados = shift_points_x(points_intrados, shift)

        return points_extrados + points_intrados[::-1]

    def __str__(self) -> str:
        """
        Return a string description of this arch.
        """
        params = {
            'thickness_top': self.thickness_top,
            'thickness_bottom': self.thickness_bottom
            }

        return super().__str__(params)


# ------------------------------------------------------------------------------
# Helper functions
# ------------------------------------------------------------------------------

def points_elliptical_arc(
        height: float, 
        width: float, 
        num_points: int        
        ) -> list[list[float]]:
    """Generate points on a planar elliptical arc.
    
    Parameters
    ----------
    height : float
        The height of the parabolic arc.
    width : float
        The width of the parabolic arc.
    num_points : int
        The number of points to generate.
    
    Returns
    -------
    list[list[float]]
        List of [x, y, z] coordinates of points on the arc.
        First point is [0, 0, 0].
        Last point is [width, height, 0].
    """
    if num_points < 2:
        raise ValueError("Number of points must be at least 2")
    
    points = []    
    for theta in linspace(pi, pi * 0.5, num_points):
        x = 0.5 * width * cos(theta)
        y = height * sin(theta)        
        point = [x, y, 0.0]        
        points.append(point)

    return points


def points_elliptical_arc_offset(
        height: float, 
        width: float, 
        offset: float,
        num_points: int,
        ) -> list[list[float]]:
    """Generate points on a planar elliptical arc.
    
    Parameters
    ----------
    height : float
        The height of the parabolic arc.
    width : float
        The width of the parabolic arc.
    offset : float
        The offset of the arc.
    num_points : int
        The number of points to generate.
    
    Returns
    -------
    list[list[float]]
        List of [x, y, z] coordinates of points on the arc.
        First point is [0, 0, 0].
        Last point is [width - offset, height - offset, 0].
    """
    if num_points < 2:
        raise ValueError("Number of points must be at least 2")
        
    points = []    
    for theta in linspace(pi, pi * 0.5, num_points):
        # Compute coordinates
        x = 0.5 * width * cos(theta)
        y = height * sin(theta)

        # Compute unit normals
        nx = width * cos(theta)
        ny = height * sin(theta)
        norm = sqrt(nx**2 + ny**2)
        nx /= norm
        ny /= norm

        # Offset coordinates
        x = x + offset * nx
        y = y + offset * ny      
        
        point = [x, y, 0.0]        
        points.append(point)

    return points


def linspace(start: float, stop: float, num: int, endpoint: bool = True) -> list[float]:
    """
    Return evenly spaced numbers over a specified interval.

    Returns a list of evenly spaced numbers over the specified interval.

    Parameters
    ----------
    start : float
        The start of the interval.
    stop : float
        The end of the interval.
    num : int
        The number of points to generate.
    endpoint : bool, optional
        If True, the endpoint is included.
    """
    if num <= 0:
        return []
    if num == 1:
        return [stop if endpoint else start]

    step = (stop - start) / (num - 1) if endpoint else (stop - start) / num

    return [start + i * step for i in range(num)]
